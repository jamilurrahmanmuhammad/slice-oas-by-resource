# ADR-001: Layered Architecture with 7-Phase Validation Pipeline

**Status**: Accepted

**Date**: 2025-12-17

**Context**

The slice-oas-by-resource tool must decompose large OpenAPI specifications into individual, self-contained OAS files while ensuring 100% output validity. The system needs to handle complex scenarios including transitive reference resolution, version conversion, error handling, and user-friendly interaction. The architecture must support:

- Black-box conversational UX for non-programmers
- Complete reference resolution including commonly-missed response headers
- Deterministic 7-phase validation ensuring output quality
- Real-time CSV tracking for governance
- Cross-platform compatibility (Linux, macOS, Windows)
- Performance targets: <5s for single endpoint, <3 min for 100 endpoints

**Decision**

We adopt a **layered architecture** with distinct separation of concerns:

1. **CLI Layer** (cli.py, __main__.py)
   - Conversational interface with plain language prompts
   - User input validation and path verification
   - Error message translation (technical â†’ user-friendly)
   - Progress reporting in accessible language

2. **Core Processing Layer** (parser.py, resolver.py, converter.py, slicer.py)
   - Parser: OAS file loading and version detection
   - Resolver: BFS-based reference resolution with circular detection
   - Converter: Version transformation with explicit rules
   - Slicer: Orchestrates endpoint extraction workflow

3. **Validation Layer** (validator.py)
   - **7-Phase Validation Pipeline** (Constitutional Requirement):
     1. File Structure: Valid JSON/YAML, root keys present
     2. Operation Integrity: Single path, single method, correct definition
     3. Response Integrity: Codes match, headers resolve, schemas present
     4. Reference Resolution: ALL $ref entries resolve to existing components
     5. Component Completeness: No orphaned refs, required components non-empty
     6. Payload Equivalence: Operation matches parent spec exactly
     7. Version Validation: OAS version matches requested, schema syntax correct
   - Each phase gates the next; failure at any phase rejects file

4. **Output Layer** (generator.py)
   - CSV index generation with real-time append
   - File writing with format conversion
   - Duplicate detection and deduplication

5. **Models Layer** (models.py, exceptions.py)
   - Pydantic data models with validation
   - Custom exception hierarchy for user-friendly errors

**Consequences**

### Positive

- **Clear Separation of Concerns**: Each layer has a single responsibility, making testing and maintenance straightforward
- **Testability**: Unit tests can target individual layers; integration tests verify layer interactions
- **Black-Box UX Compliance**: CLI layer cleanly separates user interaction from technical implementation
- **Deterministic Quality**: 7-phase validation ensures no invalid files are ever produced
- **Extensibility**: New validation phases, output formats, or conversion rules can be added without affecting other layers
- **Error Localization**: Failures can be traced to specific layers and phases
- **Performance Predictability**: Each layer has measurable performance characteristics

### Negative

- **Increased Module Count**: More files to maintain compared to monolithic design
- **Layer Crossing Overhead**: Data must be transformed between layers, adding minor performance cost
- **Learning Curve**: New contributors must understand layer boundaries and responsibilities
- **Potential Over-Engineering**: For very simple use cases, the layered structure may seem complex

### Risks

- **Layer Coupling**: If boundaries are not respected, layers may become tightly coupled over time
  - Mitigation: Enforce interface contracts; use dependency injection; regular architecture reviews
- **Performance Bottlenecks**: Validation pipeline processes each file 7 times
  - Mitigation: Early exit on first failure; parallel validation where possible; caching
- **Error Propagation**: Errors must traverse multiple layers to reach user
  - Mitigation: Custom exception hierarchy with context preservation; clear error translation rules

**Alternatives Considered**

### Alternative 1: Monolithic Design
- **Description**: Single module handles all operations (parsing, validation, slicing, output)
- **Pros**: Simpler initial implementation, fewer files, no layer boundaries
- **Cons**: Violates black-box principle (UX mixed with logic), difficult to test, hard to extend, unclear responsibility boundaries
- **Rejected**: Cannot achieve constitutional black-box requirement with monolithic structure

### Alternative 2: Event-Driven Pipeline
- **Description**: Each processing stage emits events consumed by next stage; async processing
- **Pros**: High performance, natural parallelization, decoupled components
- **Cons**: Unnecessary complexity for CLI tool, harder to debug, overkill for current scale
- **Rejected**: Over-engineering for synchronous, single-threaded CLI use case

### Alternative 3: Decorator Pattern for Validation
- **Description**: Validation phases implemented as decorators wrapping core extraction logic
- **Pros**: Flexible composition, clear phase boundaries, functional style
- **Cons**: Less discoverable, harder to enforce phase ordering, complex error handling
- **Rejected**: Phase ordering is critical and must be enforced; decorators make this implicit

**References**

- [Specification](/home/jamil/repos/slice-oas-by-resource/specs/001-slice-oas-by-resource/spec.md)
- [Implementation Plan](/home/jamil/repos/slice-oas-by-resource/specs/001-slice-oas-by-resource/plan.md)
- [Data Model](/home/jamil/repos/slice-oas-by-resource/specs/001-slice-oas-by-resource/data-model.md)
- Constitution: Principle I (Black Box Abstraction), Principle IV (Deterministic Validation)
