# ADR-003: BFS Graph Traversal for Reference Resolution with Circular Detection

**Status**: Accepted

**Date**: 2025-12-17

**Context**

OpenAPI specifications use `$ref` pointers to reference reusable components (schemas, parameters, headers, security schemes). When slicing a single endpoint, the system must:

- Resolve ALL transitive references (refs within refs within refs...)
- Include all referenced components in the output file
- Handle circular references gracefully (Schema A → Schema B → Schema A)
- Scan response headers explicitly (commonly missed in OAS tooling)
- Support deep reference chains (up to 100 levels per constitutional constraint)
- Avoid infinite loops and stack overflows
- Provide clear error messages for unresolved references

The reference resolution algorithm is critical because:
- It directly affects output file validity (Phase 4 validation)
- It impacts performance (must traverse potentially 1000+ components)
- It must handle edge cases (circular refs, missing refs, external refs)
- Constitutional requirement: response headers MUST be scanned explicitly

**Locations to Scan for $ref** (Constitutional Requirement):
1. Operation parameters: `paths[path][method].parameters[*].$ref`
2. Request body schema: `paths[path][method].requestBody.content[*].schema.$ref`
3. Response schemas: `paths[path][method].responses[*].content[*].schema.$ref`
4. **Response headers**: `paths[path][method].responses[*].headers[*].$ref` ← **CRITICAL**
5. Security schemes: `paths[path][method].security[*]` → components.securitySchemes
6. Nested schemas: Within any schema, check `properties[*]`, `items`, `allOf`, `oneOf`, `anyOf`, `not`

**Decision**

We implement **Breadth-First Search (BFS) with Visited Set** for reference resolution with explicit response header scanning:

### Algorithm Structure

```python
def resolve_all_references(operation: dict, components: dict) -> dict:
    """Resolve all transitive references for a single operation."""
    refs_to_process = deque()
    visited_refs = set()
    resolved_components = {
        'schemas': {},
        'parameters': {},
        'headers': {},
        'securitySchemes': {}
    }

    # Phase 1: Collect initial refs from operation
    refs_to_process.extend(extract_parameter_refs(operation))
    refs_to_process.extend(extract_request_body_refs(operation))
    refs_to_process.extend(extract_response_refs(operation))
    refs_to_process.extend(extract_response_header_refs(operation))  # CRITICAL
    refs_to_process.extend(extract_security_refs(operation))

    # Phase 2: BFS traversal
    while refs_to_process:
        ref_string = refs_to_process.popleft()

        if ref_string in visited_refs:
            continue  # Already processed (handles circular refs)

        visited_refs.add(ref_string)
        component_type, component_name = parse_ref(ref_string)
        component_content = fetch_from_components(components, component_type, component_name)

        if component_content is None:
            raise UnresolvedReferenceError(ref_string)

        # Store resolved component
        resolved_components[component_type][component_name] = component_content

        # Phase 3: Extract nested refs from this component
        nested_refs = extract_nested_refs(component_content)
        refs_to_process.extend(nested_refs)

    return resolved_components
```

### Key Features

1. **BFS Queue**: Uses `collections.deque` for efficient FIFO processing
2. **Visited Set**: Tracks processed refs to prevent infinite loops on circular references
3. **Explicit Header Scanning**: `extract_response_header_refs()` explicitly scans `responses[*].headers[*].$ref`
4. **Depth Safeguard**: Track traversal depth, fail if >100 levels (constitutional constraint)
5. **Error Clarity**: `UnresolvedReferenceError` includes ref path and location for debugging

### Complexity

- **Time**: O(V + E) where V = unique components, E = total $ref entries
- **Space**: O(V) for visited set and resolved components dictionary

**Consequences**

### Positive

- **Natural Deduplication**: Visited set ensures each component is processed exactly once
- **Circular Reference Safety**: No infinite loops; circular refs are valid and preserved in output
- **Constitutional Compliance**: Explicit response header scanning ensures no missed references
- **Level-by-Level Processing**: Aligns with validation phase structure; easier to debug
- **Depth Control**: Max-depth safeguard prevents stack overflow on pathological inputs
- **Clear Error Messages**: Unresolved refs can show complete path from operation to missing component
- **Performance Predictability**: O(V+E) complexity is well-understood and deterministic

### Negative

- **Memory Overhead**: Queue and visited set consume memory proportional to reference count
  - Acceptable: 1000 components × ~100 bytes ≈ 100KB (well within <200MB budget)
- **Single-Threaded**: BFS is inherently sequential; no parallelization
  - Acceptable: Reference resolution is fast (<1s for typical files); parallelization adds complexity

### Risks

- **Deep Reference Chains**: Pathological inputs with 100+ levels could hit depth limit
  - Mitigation: Depth limit is constitutional requirement; fail with clear message if exceeded
- **Large Component Count**: Files with 10,000+ components may be slow
  - Mitigation: Performance testing with large fixtures; optimize if needed
- **External References**: Tool does not support external $refs (HTTP URLs, file paths)
  - Mitigation: Detect external refs early, fail with actionable error message

**Alternatives Considered**

### Alternative 1: Depth-First Search (DFS) with Visited Set
- **Description**: Recursive DFS traversal with visited set to prevent cycles
- **Pros**: Simpler code (recursive), handles circular refs naturally
- **Cons**:
  - Stack overflow risk on deep chains (Python has recursion limit)
  - No advantage over BFS for this use case
  - Harder to implement max-depth safeguard
- **Rejected**: BFS provides same guarantees with better depth control

### Alternative 2: Topological Sort with Dependency Graph
- **Description**: Build complete dependency graph, detect cycles, topologically sort, then resolve in order
- **Pros**:
  - Optimal resolution order
  - Explicit cycle detection
  - Dependency visualization possible
- **Cons**:
  - More complex implementation (two passes: graph build + sort)
  - Circular refs are valid in OAS (not errors), so topological sort less useful
  - Higher constant factor in O(V+E) complexity
- **Rejected**: Unnecessary complexity; circular refs are not errors in OAS

### Alternative 3: Lazy Resolution (Resolve on Demand)
- **Description**: Only resolve refs when actually needed during output generation
- **Pros**:
  - Minimal work (only resolve what's used)
  - Faster for sparse reference graphs
- **Cons**:
  - Complex state management (partial resolution)
  - Harder to validate completeness
  - Error detection delayed until output phase
  - Violates "fail fast" principle
- **Rejected**: Upfront resolution provides clear error messages and aligns with validation pipeline

### Alternative 4: Memoization with Recursion
- **Description**: Recursive resolution with memoization cache to avoid re-processing
- **Pros**: Functional style, elegant code
- **Cons**:
  - Same stack overflow risk as DFS
  - Cache invalidation complexity
  - No clear advantage over BFS with visited set
- **Rejected**: BFS is more straightforward and avoids recursion limits

**References**

- [Specification](/home/jamil/repos/slice-oas-by-resource/specs/001-slice-oas-by-resource/spec.md) - FR-005 to FR-008 (reference resolution requirements)
- [Implementation Plan](/home/jamil/repos/slice-oas-by-resource/specs/001-slice-oas-by-resource/plan.md) - Technical Context lines 22-24
- [Research: Reference Resolution Algorithm](/home/jamil/repos/slice-oas-by-resource/specs/001-slice-oas-by-resource/research.md#research-task-2-reference-resolution-algorithm)
- [Data Model: Reference and ResolvedComponent](/home/jamil/repos/slice-oas-by-resource/specs/001-slice-oas-by-resource/data-model.md) - Lines 120-204
- Constitution: Principle III (Complete Reference Resolution with Version Fidelity)
