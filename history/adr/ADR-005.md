# ADR-005: Black Box CLI UX with Plain-Language Conversion

**Status**: Accepted

**Date**: 2025-12-17

**Context**

The slice-oas-by-resource tool targets both technical and non-technical users, including:
- API architects and engineers (technical)
- Technical writers and documentation specialists (semi-technical)
- DevOps engineers (technical)
- Product managers and governance teams (non-technical)

Constitutional requirement (Principle I: Black Box Abstraction):
> "Users must never see code, JSON/YAML structures, or algorithm details during normal operation. All interactions should be conversational and use plain language."

Success criteria mandate:
- **SC-005**: Non-programmer users can complete the entire extraction workflow without seeing code or technical implementation details
- **SC-009**: Error messages are actionable and understandable to non-technical users in 95% of cases

The UX design must:
- Hide all technical complexity from users
- Provide conversational prompts for all inputs
- Convert technical errors to plain language with actionable guidance
- Display progress in accessible language
- Require no programming knowledge or command-line expertise
- Still provide debug output for technical users when requested (opt-in)

**Decision**

We implement a **Black Box CLI UX** with the following components:

### 1. Conversational Interface Layer

**CLI Interaction Pattern**:
```
Welcome to OpenAPI Endpoint Extractor

I'll help you extract individual API endpoints from your OpenAPI specification file.

First, I need the path to your OpenAPI file.
Please enter the full file path: _
```

**User Input Validation with Friendly Feedback**:
```
> /invalid/path/api.yaml

The file path you provided doesn't exist.
Please check the path and try again. Make sure you're using the complete file path.
Example: /home/user/documents/api.yaml

Please enter the full file path: _
```

### 2. Error Message Translation

All internal exceptions are translated to user-friendly messages using templates:

**Error Message Structure**:
```python
class UserFriendlyError(Exception):
    def __init__(self, message: str, guidance: str, technical_detail: str = None):
        self.message = message  # Plain language description
        self.guidance = guidance  # Actionable next steps
        self.technical_detail = technical_detail  # For debugging (hidden by default)
```

**Error Categories** (Full templates in research.md):
1. **File Path Errors**: "The file path you provided doesn't exist" + actionable guidance
2. **OAS Validation Errors**: "This doesn't appear to be an OpenAPI specification file" + how to fix
3. **Resource Specification Errors**: "The path '/users/{id}' doesn't exist in this file" + available options
4. **Reference Resolution Errors**: "The endpoint references a component that doesn't exist" + context
5. **Version Conversion Errors**: "This endpoint uses advanced rules that require OpenAPI 3.1" + solution
6. **Validation Phase Failures**: Translated per phase with actionable guidance

### 3. Progress Messaging (No Technical Jargon)

**Instead of**:
```
Parsing OAS file...
Resolving transitive references with BFS...
Running 7-phase validation pipeline...
```

**We display**:
```
Reading your OpenAPI file...
Gathering all required components...
Validating the extracted endpoint...
Writing output file...
```

### 4. Success Messages (Plain Language Summary)

**Instead of**:
```
{
  "status": "success",
  "output_file": "/output/users-id-get.yaml",
  "validation_results": [...]
}
```

**We display**:
```
Success! Extracted GET /users/{id}

Output saved to: /output/users-id-get.yaml
File size: 12.3 KB
Schemas included: 5
OpenAPI version: 3.1.0

The file is ready to use with any OpenAPI tool.
```

### 5. Debug Mode (Opt-In for Technical Users)

**Default Behavior** (Black Box):
```
Error: The endpoint references a component that doesn't exist in the file.

Please check the source file for broken references.
```

**With --debug Flag**:
```
Error: The endpoint references a component that doesn't exist in the file.

Please check the source file for broken references.

Technical details:
  Unresolved reference: #/components/schemas/User
  Location: paths./users/{id}.get.responses.200.content.application/json.schema
  Phase: 4 (Reference Resolution)
  Timestamp: 2025-12-17T10:30:00Z
```

### 6. No Code/JSON/YAML Display

**Prohibited** (violates black box):
- Displaying parsed OAS content
- Showing JSON/YAML structures in terminal
- Exposing algorithm details or internal state
- Printing stack traces to users
- Displaying raw validation errors from libraries

**Allowed**:
- Plain language status messages
- File paths and filenames
- Numeric metadata (file size, schema count, etc.)
- User-provided input echoed back for confirmation
- Success/failure indicators

**Consequences**

### Positive

- **Accessibility**: Non-programmers can use the tool without technical knowledge
- **User Confidence**: Clear, actionable messages reduce frustration and support burden
- **Constitutional Compliance**: Satisfies Principle I (Black Box Abstraction)
- **Professional UX**: Tool feels polished and user-friendly, not like a developer prototype
- **Error Recovery**: Actionable guidance helps users fix issues without consulting documentation
- **Broad Adoption**: Lower barrier to entry increases potential user base
- **Opt-In Complexity**: Technical users can enable debug mode when needed

### Negative

- **Implementation Overhead**: Every error path requires message translation logic
  - Mitigation: Template-based error messages (research.md); unit tests for message quality
- **Information Hiding**: Technical users may want more detail by default
  - Mitigation: --debug flag provides full technical output on demand
- **Message Maintenance**: Error templates must be updated when code changes
  - Mitigation: Centralize templates in exceptions.py; test coverage for all error paths

### Risks

- **Ambiguous Messages**: Oversimplifying may hide critical details
  - Mitigation: Balance simplicity with specificity; user testing to validate message clarity
- **Inconsistent Tone**: Different contributors may write messages differently
  - Mitigation: Style guide for error messages; review process for new messages
- **Translation Gaps**: Some technical errors may be hard to translate
  - Mitigation: Fall back to "This is an internal error, please report" for truly unexpected failures

**Alternatives Considered**

### Alternative 1: Traditional Command-Line Tool
- **Description**: Standard CLI with flags, technical error messages, raw output
- **Pros**: Faster to implement, familiar to developers, no message translation needed
- **Cons**:
  - Violates constitutional black-box requirement
  - Excludes non-technical users
  - Poor user experience for target audience (technical writers, PMs)
- **Rejected**: Fails constitutional requirement; misaligned with user base

### Alternative 2: API-First Design (Programmatic Interface)
- **Description**: Provide Python API/library; CLI is thin wrapper
- **Pros**: Flexibility for developers, embeddable in other tools, powerful automation
- **Cons**:
  - Non-programmers cannot use it
  - Requires coding skills
  - Violates black-box principle
- **Rejected**: Not aligned with non-programmer user scenario; can be future enhancement

### Alternative 3: GUI Application
- **Description**: Desktop application with point-and-click interface
- **Pros**: Maximum accessibility, visual feedback, file browsers for path selection
- **Cons**:
  - Much higher development cost (UI frameworks, cross-platform testing)
  - Harder to automate or integrate into workflows
  - Deployment complexity (installers, signing, updates)
- **Rejected**: Over-engineering for initial version; CLI meets requirements with lower cost

### Alternative 4: Interactive TUI (Terminal UI)
- **Description**: Full-screen terminal interface with menus and forms (like `htop`)
- **Pros**: Rich visual feedback, guided workflows, no GUI development needed
- **Cons**:
  - More complex than conversational CLI
  - Steeper learning curve for developers
  - Accessibility issues (screen readers)
- **Rejected**: Conversational CLI is simpler and more accessible

**References**

- [Specification](/home/jamil/repos/slice-oas-by-resource/specs/001-slice-oas-by-resource/spec.md) - FR-031 to FR-036 (UX requirements), User Story 5
- [Implementation Plan](/home/jamil/repos/slice-oas-by-resource/specs/001-slice-oas-by-resource/plan.md) - Constitution Check: Principle I
- [Research: Black-Box Error Message Design](/home/jamil/repos/slice-oas-by-resource/specs/001-slice-oas-by-resource/research.md#research-task-5-black-box-error-message-design)
- Success Criteria: SC-005, SC-009
- Constitution: Principle I (Black Box Abstraction - User Experience FIRST)
