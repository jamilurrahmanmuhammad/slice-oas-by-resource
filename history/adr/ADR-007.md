# ADR-007: Version-Aware Transformation (3.0↔3.1) with Family-Based Strategy

**Status**: Accepted

**Date**: 2025-12-17

**Context**

OpenAPI has two major version families: 3.0.x (3.0.0-3.0.4) and 3.1.x (3.1.0+). The slice-oas-by-resource tool must support:

- **FR-002**: Support OpenAPI versions 3.0.x and 3.1.x as input
- **FR-018**: Convert OpenAPI 3.0.x specifications to 3.1.x during extraction
- **FR-019**: Convert OpenAPI 3.1.x specifications to 3.0.x during extraction
- **FR-020**: Ensure version conversion is deterministic (repeated conversions produce identical output)
- **FR-021**: Correctly transform standard OpenAPI constructs during version conversion
- **SC-006**: Version conversion produces deterministic output (repeated conversions yield identical files)

Constitutional requirement (Principle III & OAS Version Strategy):
> "Version-specific transformation rules for 3.0↔3.1 with family-level (not patch-level) grouping"

Version differences between 3.0.x and 3.1.x:
- **3.1.x introduces**: JSON Schema 2020-12, `webhooks`, `pathItems` in components, `mutualTLS` security
- **3.1.x changes**: `nullable: true` → `type: [original, "null"]`, license `identifier` field
- **3.1.x incompatible**: `if/then/else` conditionals, `unevaluatedProperties`, multi-type unions (non-nullable)

The version conversion strategy must:
- Auto-detect input version from `openapi` field
- Allow explicit user selection of output version
- Apply correct transformation rules based on direction (3.0→3.1 or 3.1→3.0)
- Fail deterministically when conversion is impossible (no silent data loss)
- Preserve all data when conversion is lossless
- Provide clear user guidance when conversion fails

**Decision**

We implement **Version-Aware Transformation with Family-Based Strategy**:

### Version Detection and Grouping

**Family-Level Grouping** (not patch-level):
- **3.0.x family**: 3.0.0, 3.0.1, 3.0.2, 3.0.3, 3.0.4
- **3.1.x family**: 3.1.0, 3.1.1, ...

**Rationale**: Patch versions within a family are backward-compatible; transformation rules apply at family level.

**Auto-Detection**:
```python
def detect_version_family(oas_content: dict) -> str:
    version = oas_content.get("openapi", "")
    if version.startswith("3.0."):
        return "3.0.x"
    elif version.startswith("3.1."):
        return "3.1.x"
    else:
        raise UnsupportedVersionError(version)
```

### Transformation Rules

#### 3.0.x → 3.1.x (Lossless - 3.1 is Superset)

| Feature | 3.0.x | 3.1.x Transformation | Convertible? |
|---------|-------|---------------------|--------------|
| `nullable: true` | `type: string, nullable: true` | `type: ["string", "null"]` | ✓ Yes |
| `webhooks` | N/A | Add empty `webhooks: {}` | ✓ Yes |
| `pathItems` in components | N/A | Keep as-is (valid in 3.1) | ✓ Yes |
| `examples` in schema | `example: "foo"` | Keep as `example` or convert to `examples: ["foo"]` | ✓ Yes |
| All other constructs | Keep as-is | Keep as-is (3.1 is superset) | ✓ Yes |

**Implementation**:
```python
class NullableToTypeArrayRule(TransformationRule):
    applies_to = ConversionDirection.TO_3_1

    def transform(self, content: dict, location: str) -> dict:
        if "nullable" in content and content["nullable"] is True:
            original_type = content.get("type", "string")
            content["type"] = [original_type, "null"]
            del content["nullable"]
        return content
```

#### 3.1.x → 3.0.x (Lossy - Fail on Unconvertible)

| Feature | 3.1.x | 3.0.x Transformation | Convertible? |
|---------|-------|---------------------|--------------|
| `type: ["string", "null"]` | Nullable type array | `type: string, nullable: true` | ✓ Yes |
| `type: ["string", "integer"]` | Multi-type union | **FAIL** with message | ✗ No |
| `webhooks` section | Webhooks object | Remove entire section | ✓ Yes (with data loss) |
| `pathItems` in components | Path item objects | Remove from components | ✓ Yes (with data loss) |
| `mutualTLS` security | Mutual TLS scheme | Remove + warn user | ⚠ Partial (loss of security info) |
| JSON Schema `if/then/else` | Conditionals | **FAIL** with message | ✗ No |
| `unevaluatedProperties` | Schema keyword | **FAIL** with message | ✗ No |
| License `identifier` only | SPDX identifier | **FAIL** if no `url` | ✗ No |
| License `identifier` + `url` | Both fields | Keep only `url` | ✓ Yes |

**Pre-Conversion Validation** (Fail Fast Strategy):
```python
def validate_convertible_to_3_0(oas_content: dict) -> bool:
    """Check if OAS 3.1.x can be converted to 3.0.x without data loss."""
    issues = []

    # Check for JSON Schema conditionals
    if has_json_schema_conditionals(oas_content):
        issues.append("Uses JSON Schema 'if/then/else' conditionals")

    # Check for multi-type unions (excluding nullables)
    if has_multi_type_unions(oas_content):
        issues.append("Uses multi-type unions (e.g., type: ['string', 'integer'])")

    # Check for unevaluatedProperties
    if has_unevaluated_properties(oas_content):
        issues.append("Uses 'unevaluatedProperties' keyword")

    # Check for identifier-only license
    if has_identifier_only_license(oas_content):
        issues.append("License uses 'identifier' without 'url'")

    if issues:
        raise UnconvertibleStructureError(
            "Cannot convert to OAS 3.0.x:\n" + "\n".join(f"- {i}" for i in issues) +
            "\n\nPlease use OAS 3.1.x output format for this endpoint."
        )

    return True
```

### Conversion Workflow

```python
class VersionConverter:
    def convert(self, oas_content: dict, target_version: str) -> dict:
        source_version = detect_version_family(oas_content)

        if source_version == target_version:
            return oas_content  # No conversion needed

        if target_version == "3.0.x":
            # Pre-validate before conversion
            self.validate_convertible_to_3_0(oas_content)
            return self.convert_to_3_0(oas_content)
        else:
            return self.convert_to_3_1(oas_content)
```

### User-Facing Error Messages

**Technical Error**:
```
UnconvertibleStructureError: Schema contains if/then/else keywords incompatible with OAS 3.0.x
```

**User-Friendly Translation**:
```
This endpoint uses advanced validation rules that require OpenAPI 3.1 format.

Please select '3.1' as your output version instead of '3.0'.
```

**Consequences**

### Positive

- **Deterministic**: Same input + same target version → same output (constitutional requirement)
- **Fail Fast**: Pre-conversion validation catches unconvertible structures before processing
- **No Silent Data Loss**: All conversions are explicit; failures have clear messages
- **Family-Based Strategy**: Simple grouping (3.0.x vs 3.1.x) avoids patch-level complexity
- **Constitutional Compliance**: Satisfies Principle III and OAS Version Strategy requirements
- **User Guidance**: Clear error messages tell users exactly how to fix conversion issues
- **Lossless 3.0→3.1**: All 3.0.x features are preserved when converting to 3.1.x
- **Explicit 3.1→3.0**: Lossy conversions are user-approved (fail by default)

### Negative

- **Conversion Failures**: Some 3.1.x files cannot be converted to 3.0.x
  - Mitigation: Clear error messages with actionable guidance; user can choose 3.1.x output
- **Implementation Complexity**: Transformation rules add code and test surface area
  - Mitigation: Rule-based architecture; unit tests per rule; extensive fixtures
- **Version-Specific Bugs**: Edge cases in version conversion may be missed
  - Mitigation: Research phase documented all known differences; comprehensive test coverage

### Risks

- **New 3.1.x Features**: Future OAS 3.1.x versions may introduce new keywords
  - Mitigation: Family-based strategy handles minor versions automatically; monitor OAS spec updates
- **Unconvertible Detection Gaps**: May miss some unconvertible structures
  - Mitigation: Phase 7 validation catches schema errors; openapi-spec-validator is final check
- **Performance Overhead**: Transformation rules add processing time
  - Mitigation: Rules are simple transforms (no complex logic); performance target (<5s) is met

**Alternatives Considered**

### Alternative 1: Version-Agnostic Slicing (No Conversion)
- **Description**: Only output same version as input; no conversion support
- **Pros**: Much simpler, no conversion logic, no edge cases
- **Cons**:
  - Violates FR-018 and FR-019 (conversion required)
  - Poor user experience (must manually convert before or after slicing)
- **Rejected**: Conversion is explicit functional requirement

### Alternative 2: Patch-Level Versioning
- **Description**: Treat each patch version (3.0.0, 3.0.1, ...) separately
- **Pros**: Maximum precision, handles patch-level differences
- **Cons**:
  - Unnecessary complexity (patch versions are backward-compatible)
  - More transformation rule sets to maintain
  - No practical benefit (differences are at family level)
- **Rejected**: Family-level strategy is simpler and sufficient

### Alternative 3: Manual Conversion (User Responsibility)
- **Description**: User must convert file externally before slicing
- **Pros**: Tool is simpler, no conversion code needed
- **Cons**:
  - Poor user experience (extra manual step)
  - Violates functional requirements (FR-018, FR-019)
  - Doesn't leverage tool's OAS knowledge
- **Rejected**: Conversion is core feature, not optional

### Alternative 4: Best-Effort Conversion with Warnings
- **Description**: Convert what's possible, skip unconvertible parts, log warnings
- **Pros**: Maximizes conversion success rate
- **Cons**:
  - Non-deterministic (what gets skipped?)
  - Silent data loss (users may not see warnings)
  - Violates FR-020 (deterministic requirement)
  - Confusing user experience
- **Rejected**: Deterministic conversion is constitutional requirement

**References**

- [Specification](/home/jamil/repos/slice-oas-by-resource/specs/001-slice-oas-by-resource/spec.md) - FR-018 to FR-021 (version conversion requirements)
- [Implementation Plan](/home/jamil/repos/slice-oas-by-resource/specs/001-slice-oas-by-resource/plan.md) - Constitution Check: OAS Version Strategy
- [Research: Version Conversion Strategies](/home/jamil/repos/slice-oas-by-resource/specs/001-slice-oas-by-resource/research.md#research-task-3-version-conversion-strategies)
- [Data Model: VersionConverter and TransformationRule](/home/jamil/repos/slice-oas-by-resource/specs/001-slice-oas-by-resource/data-model.md) - Lines 295-387
- Success Criteria: SC-006
- Constitution: Principle III (Complete Reference Resolution with Version Fidelity), OAS Version Strategy
