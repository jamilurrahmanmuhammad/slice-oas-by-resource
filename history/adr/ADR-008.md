# ADR-008: File-Based Storage with Local Filesystem Only

**Status**: Accepted

**Date**: 2025-12-17

**Context**

The slice-oas-by-resource tool must handle input and output for OpenAPI specification files. The storage strategy affects:

- Deployment complexity and portability
- Performance characteristics
- Offline capability
- Security and access control
- User experience (file path specification)
- Integration with other tools and workflows

Functional requirements include:
- **FR-001**: System MUST accept an explicit file path to an OpenAPI specification file as input
- **FR-036**: System MUST require explicit file paths from users (no automatic directory discovery)
- **FR-037**: Complete single endpoint extraction in under 5 seconds for typical OAS files (up to 1MB)
- **FR-038**: Handle OAS files containing up to 1000 endpoints without failure

Assumptions include:
- Users have read access to source OAS files
- Users have write permissions to output directories
- Files are stored on local or network-accessible filesystem
- No authentication required to access files

The storage strategy must:
- Work offline (no internet dependency)
- Be cross-platform (Linux, macOS, Windows)
- Support both JSON and YAML formats
- Handle files up to 10MB+ without performance degradation
- Require no external services or databases

**Decision**

We adopt **File-Based Storage with Local Filesystem Only**:

### Architecture Components

1. **Input**: Local filesystem files only
   - User provides absolute or relative file path
   - Tool reads file using Python file I/O
   - No network calls, no database queries, no cloud storage

2. **Output**: Local filesystem files only
   - User specifies output directory path
   - Tool writes sliced OAS files to directory
   - CSV index written to same directory
   - No remote storage, no database persistence

3. **Processing**: Entirely in-memory
   - Parse input file into Python dict
   - Transform and slice in memory
   - Write output file from memory
   - No temporary files, no intermediate storage

### Data Flow

```
User provides paths
       ↓
[Input OAS File] → [Read into memory] → [Parse & Validate]
       ↓                                        ↓
   (Local FS)                         [In-Memory Processing]
                                                ↓
                                     [Slice & Transform]
                                                ↓
                                     [Validation Pipeline]
                                                ↓
                              [Write Output] → [Output OAS File]
                                    ↓                ↓
                              [CSV Index]        (Local FS)
                                    ↓
                                (Local FS)
```

### Storage Constraints

**No Database**:
- No SQLite, PostgreSQL, MySQL, etc.
- All data stored as files (OAS files, CSV index)

**No Network Calls**:
- No HTTP requests to fetch remote OAS files
- No cloud storage integration (S3, Azure Blob, GCS)
- No remote validation services

**No Automatic Discovery**:
- No glob patterns, no directory scanning
- User must provide explicit file paths
- No "find all .yaml files in this directory" features

**Local/Network Filesystem Only**:
- Files on local disk (SSD, HDD)
- Network-mounted filesystems (NFS, SMB/CIFS) supported (standard file I/O)
- No special filesystem features required

### File Path Handling

**Absolute Paths** (Preferred):
```python
/home/user/api-specs/petstore.yaml
/mnt/network/specs/users-api.yaml
C:\Users\user\Documents\api.yaml
```

**Relative Paths** (Converted to Absolute):
```python
./specs/api.yaml  →  /current/working/dir/specs/api.yaml
../shared/api.yaml  →  /current/working/../shared/api.yaml
```

**Validation**:
- Check file exists and is readable before processing
- Check output directory exists and is writable
- Provide clear error messages for invalid paths

**Consequences**

### Positive

- **Simplicity**: No database setup, no network configuration, no authentication
- **Portability**: Works anywhere Python runs; no external dependencies
- **Offline Capability**: Tool works without internet connection
- **Security**: No network exposure, no cloud credentials, no remote attacks
- **Performance**: File I/O is fast; no network latency
- **Debugging**: Easy to inspect inputs/outputs with standard file tools
- **Integration**: Easy to integrate with file-based workflows (git, CI/CD, scripts)
- **Constitutional Compliance**: Satisfies Principle II (Explicit Path Input)
- **Cross-Platform**: Standard file I/O works on Linux, macOS, Windows
- **No Lock-In**: No vendor-specific storage APIs

### Negative

- **Scalability Limits**: Cannot handle massive datasets (10GB+ files)
  - Acceptable: Target is <10MB files; larger files are out of scope
- **No Collaboration Features**: No built-in sharing, versioning, or locking
  - Acceptable: Users can use git or other tools for collaboration
- **Manual Path Management**: Users must know and type file paths
  - Acceptable: Black-box UX provides helpful prompts and validation
- **No Centralized Index**: CSV index is per-directory, not global
  - Acceptable: Governance use case works with directory-level indexes

### Risks

- **Large File Performance**: Files >10MB may be slow to parse
  - Mitigation: Document file size limits; use streaming parsers if needed
- **Disk Space Exhaustion**: Batch operations may fill disk
  - Mitigation: Document expected output size; users responsible for disk space
- **Path Security**: User-provided paths may point to sensitive files
  - Mitigation: Validate paths; fail on permission errors with clear message
- **Cross-Platform Path Issues**: Windows vs Unix path separators
  - Mitigation: Use `pathlib.Path` for cross-platform path handling

**Alternatives Considered**

### Alternative 1: Cloud Storage Integration
- **Description**: Support S3, Azure Blob, Google Cloud Storage URLs
- **Pros**:
  - Enables cloud-native workflows
  - Centralized storage for teams
  - Built-in versioning and access control
- **Cons**:
  - Requires authentication (API keys, OAuth)
  - Network dependency (no offline mode)
  - Platform-specific SDKs (AWS SDK, Azure SDK, etc.)
  - Complexity for local-first users
  - Security concerns (credential management)
- **Rejected**: Out of scope per specification assumptions; local files meet requirements

### Alternative 2: Database Storage
- **Description**: Store OAS content in SQLite/PostgreSQL database
- **Pros**:
  - Structured queries (find endpoints by tag, version, etc.)
  - Centralized index across all extractions
  - ACID guarantees for concurrent operations
- **Cons**:
  - Setup overhead (database creation, schema management)
  - Not portable (requires database installation)
  - Harder to inspect/debug than files
  - Users must export to files for downstream tools
  - Violates simplicity principle
- **Rejected**: Over-engineering; files meet all requirements with lower complexity

### Alternative 3: Git Integration
- **Description**: Automatically commit sliced files to git repository
- **Pros**:
  - Built-in versioning and history
  - Collaboration-friendly (push/pull)
  - Traceability (who extracted what, when)
- **Cons**:
  - Assumes git is installed and configured
  - Requires git repository (not all users use git)
  - Auto-commit is invasive (users may not want this)
  - Out of scope per specification (Assumption 7)
- **Rejected**: Out of scope; users can manually commit if desired

### Alternative 4: HTTP API for Remote Files
- **Description**: Support HTTP(S) URLs for input files
- **Pros**:
  - Fetch OAS files from remote servers
  - Integration with API gateways, documentation sites
  - No local file requirement
- **Cons**:
  - Network dependency (no offline mode)
  - Authentication complexity (basic auth, OAuth, API keys)
  - Security risks (downloading untrusted files)
  - Violates explicit path requirement (URLs are not paths)
- **Rejected**: Out of scope per specification assumptions (Assumption 1)

### Alternative 5: Stdin/Stdout Streams
- **Description**: Accept input from stdin, write output to stdout (Unix pipe style)
- **Pros**:
  - Composable with Unix tools (cat, grep, etc.)
  - No file path needed
  - Scriptable workflows
- **Cons**:
  - Violates explicit path requirement (FR-001, FR-036)
  - CSV index cannot be written to stdout
  - Black-box UX requires interactive prompts (conflicts with pipe usage)
  - Confusing for non-technical users
- **Rejected**: Violates functional requirements and constitutional principles

**References**

- [Specification](/home/jamil/repos/slice-oas-by-resource/specs/001-slice-oas-by-resource/spec.md) - FR-001, FR-036, Assumptions 1, 2, 7
- [Implementation Plan](/home/jamil/repos/slice-oas-by-resource/specs/001-slice-oas-by-resource/plan.md) - Technical Context: Storage (line 16)
- Constitution: Principle II (Explicit Path Input - No Auto-Discovery)
- Assumptions: Assumption 1 (Input File Accessibility), Assumption 7 (File System Storage)
